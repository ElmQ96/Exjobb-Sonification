//Patterns are a diverse family of classes in SC that represent algorithmic sequences of data

/*
Help resources:

https://ccrma.stanford.edu/~ruviaro/texts/A_Gentle_Introduction_To_SuperCollider.pdf

http://doc.sccode.org/Tutorials/A-Practical-Guide/PG_01_Introduction.html

https://www.youtube.com/watch?v=nB_bVJ1c1Rg

http://doc.sccode.org/Tutorials/Streams-Patterns-Events1.html

http://doc.sccode.org/Classes/Pattern.html
*/

//Patters (P-objects) are a stateless, timeless representation of a sequence of information. Streams are the executable, performable version of Patterns. Streams respond to next, nextN(num), and reset.

(
p = Pseq([10,20,30,90], 2); //sequence through the array twice
x = p.asStream;
)

x.next; //return next value

x.nextN(10); //return next 10 values (nil if reached the end)

x.reset; //start over at beginning

x.next;

(
//inf repeats to specify no end
p = Pseq([10,20,30,90], inf);
x = p.asStream;
)

x.nextN(50);
x.reset;
x.next;

(
//randomly choose from a collection
p = Prand([10,20,30,90], inf);
x = p.asStream;
)

x.nextN(30);

//similar to this simpler operation
{ [10,20,30,90].choose }!30

(
//patterns can be nested inside one another for more complex sequences
p = Pseq([ //outer sequence
	Pseq([4,6,8,12],1), //first, sequence through these four values once
	Prand([50,51,52],1) //then randomly pick one from this collection
], inf); //repeat forever
x = p.asStream;
)

x.nextN(15);

(
//Pbind defines a sequences of Events. An Event is an "environment that defines an action." Events are a very abstract and flexible class that is usually beyond the scope of an introductory lecture. There is a default Event, a default Event type (a 'note' event, which instantiates a Synth on the server), a protoEvent (containing default parameters), and a default SynthDef. Basically, there's a lot of under-the-hood architecture that makes Pbind work so simply and elegantly on the surface!

p = Pbind(
	\freq, 1000,
	\dur, 0.3,
	\amp, 0.5,
	\sustain, 0.1,
).play
)

p.stop;

(
//by default, Pbind plays the default event type ('note') using the default SynthDef (named 'default'), so the following is equivalent, but not necessary to add. Only added here for clarity:

p = Pbind(
	\type, \note,
	\instrument, \default,
	\freq, 1000,
	\dur, 0.3,
	\amp, 0.5,
	\sustain, 0.1,
).play
)

p.stop;

//Here is an example of an individual default event:
(freq:1000, amp:0.2, sustain:2).play;

//It's even possible to do this, using ALL the default values:
().play; //!!

x = Synth.new(\default); //a Synth manually created using the default SynthDef

x.set(\gate, 0); //needs to be released manually, too (the sustain key handles this release inside of Pbind)

Event.eventTypes.keys; //all event types (it's also possible to create your own, but this is a pretty rare requirement


(
//using value patterns inside of a Pbind gives lots of rich algorithmic synthesis control. Here, just using Pseq to control oscillator pitch:

p = Pbind(
	\freq, Pseq((5..9)*100,inf),
	\dur, 0.2,
	\amp, 0.4,
	\sustain, 0.02,
);

x = p.play;
)

//When played, Pbind returns an EventStreamPlayer, captured in the global variable x. EventStreamPlayers can be stopped, resumed, and reset.

x.stop;
x.resume;
x.reset;

(
//more pattern control (choosing a random tone row)
//freq can be specified using \degree, (scale degrees) \note (full chromatic 12-tone scale), or \midinote (MIDI note numbers)
p = Pbind(
	//\freq, Pseq((5..9)*100,inf),
	\note, Pshuf((0..11),inf),
	\dur, Pseq([0.1],inf),
	\amp, Pexprand(0.2,0.5,inf),
	\sustain, 0.02,
);

x = p.trace.play; //patterns can be 'traced' to see them in the post window
)

(
//instead of tracing the events generated by Pbind, we can trace an individual, internal value pattern:
p = Pbind(
	//\freq, Pseq((5..9)*100,inf),
	\note, Pshuf((0..11),inf).trace,
	\dur, Pseq([0.1],inf),
	\amp, Pexprand(0.2,0.5,inf),
	\sustain, 0.02,
);

x = p.play;
)

(
//instead of tracing the events generated by Pbind, we can trace an individual, internal value pattern:
p = Pbind(
	//\freq, Pseq((5..9)*100,inf),
	\note, Pshuf((0..11),inf).trace,
	\dur, Pseq([0.1],inf),
	\amp, Pexprand(0.2,0.5,inf),
	\sustain, 0.02,
);

x = p.play;
)


(
//use of \degree and \scale:
p = Pbind(
	\scale, Scale.minorPentatonic,
	\degree, Pxrand([0,1,2,3,4],inf),
	\dur, Pseq([0.2],inf),
	\amp, Pexprand(0.2,0.5,inf),
	\sustain, 0.1,
);

x = p.play;
)

x.stop;

Scale.directory; //listing of all Scales (it's possible to also specify an Array of numerical scale degrees instead of Scale.whatever)

//Useful patterns I frequently use:
/*
Pseq, (sequential pattern)

Prand, Pxrand, Pwrand, (random choice from a collection)

Pwhite, Pexprand, (random choice from within a range)

Pshuf, (random order from a given collection)

Pseries, Pgeom (arithmetic/multiplicative series)
*/

//some examples:

(
//completely random choice from a collection
p = Prand((1..9),inf);
x = p.asStream;
x.nextN(20);
)

(
//random choice but never picks the same value twice in a row
p = Pxrand((1..9),inf);
x = p.asStream;
x.nextN(20);
)

(
//Pxrand doesn't work in the collection contains duplicates
p = Pxrand([1,1,2,2],inf);
x = p.asStream;
x.nextN(20);
)

(
//weighted random choice - normalizeSum is useful for arbitrary weight values
p = Pwrand([1,2,3,4],[1,3,9,30].normalizeSum,inf);
x = p.asStream;
x.nextN(100);
)

(
//random order of a collection, same random order repeated forever
p = Pshuf((0..11),inf);
x = p.asStream;
x.nextN(48);
)

(
//equivalent to exprand, always floats
p = Pexprand(1,100,inf);
x = p.asStream;
x.nextN(50)
)

(
//equivalent to rrand, ints if min & max are ints, floats if at least one of min & max is a float
p = Pwhite(1,100,inf);
x = p.asStream;
x.nextN(50)
)

(
//arithmetic series
p = Pseries(0, 5, inf);
x = p.asStream;
x.nextN(50)
)

(
//geometric series
p = Pgeom(1, -3.dbamp, inf);
x = p.asStream;
x.nextN(50)
)

//Importantly, Pbind can create Synths from any SynthDef, by specifying the instrument key in Pbind

(
SynthDef.new(\pbind_test, {
	arg freq=400, harm=4, atk=0.01, rel=1, amp=0.2, out=0;
	var sig, env;
	env = EnvGen.kr(Env.perc(atk,rel), doneAction:2);
	sig = Saw.ar([freq, freq * 0.2.midiratio]);
	sig = RLPF.ar(sig, (freq * harm).clip(20,20000), 0.5);
	sig = sig * env * amp;
	Out.ar(out, sig);
}).add;
)

(
p = Pbind(
	\instrument, \pbind_test,
	\dur, 0.2,
	\scale, Scale.minorPentatonic,
	\degree, Pxrand([0,1,2,3,4,5],inf) + Prand([-12,-5,0],inf),
	\harm, Pexprand(1,16,inf).trace,
	\amp, Pexprand(0.05,0.3),
	\atk, 0.01,
	\rel, Pexprand(0.08,10),
	\out, 0,
);

x = p.play;
)


x.stop;

//////////////////////////
//////////////////////////

//Things I meant to cover in the live stream:

//TempoClock
//EventStreamPlayers are scheduled on a TempoClock object. If not specified, they use TempoClock.default, which has a tempo of 1 beat per second (60 bpm), so seconds == beats.

(
Pbind(
	\freq, Pexprand(200,2000),
	\sustain, 0.02,
	\amp, 0.3,
	\dur, 0.75, //<-- this actually means three-quarters of a beat
).play
)

//it's possible to create your own TempoClock:

t = TempoClock.new(150/60); //150 beats per minute

(
p = Pbind(
	\freq, Pexprand(200,2000),
	\sustain, 0.02,
	\amp, 0.3,
	\dur, 0.75,
).play(t) //play on custom clock -- tempo is now faster
)

p.stop;

//command period clears schedulers on all closk and destroys all non-permanent clock objects. TempoClocks can be made permanent like this:

t = TempoClock.new(150/60).permanent_(true);

t.stop; //and destroyed manually like this ("stop the clock")


//Pseg
//Pseg is an "envelope-generator pattern"

(
//very similar to Env.new
p = Pseg(
	Pseq([0,1,0], 1), //Pseq of levels
	Pseq([5,5], 1), //Pseq of times (these are actually beats)
	Pseq([1,-1], 1) //Pseq of curves
);

//for comparison:
e = Env.new(
	[0,1,0], //from 0 to 1 to 0
	[5,5], //5 beats up, 5 beats down
	[1,-1] //slight curve away from linear
).plot;

Pbind(
	\dur, 0.1,
	\freq, Pexprand(200, 2000),
	\sustain, 0.02,
	\amp, p, //amp fades in and fades out over the course of 10 seconds, applied to all new note events that are created
).play;
)